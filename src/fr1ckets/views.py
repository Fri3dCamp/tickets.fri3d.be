# -*- coding: utf-8 -*-
# vim: ts=4:sw=4:noexpandtab
from flask import request, jsonify, session, render_template, redirect, url_for, g, abort, Response
from flask_wtf import Form
from wtforms import StringField, validators
from wtforms import SelectField, BooleanField, IntegerField
from wtforms.fields.html5 import EmailField
from fr1ckets import app
from fr1ckets.texts import texts
from fr1ckets.model import model
from fr1ckets.mail import mail
from functools import wraps
import pprint
import time
import json
import datetime

D = app.logger.debug

def check_auth_basic(u, p):
	return u == app.config['TEMP_SHIELDING_USERNAME'] and p == app.config['TEMP_SHIELDING_PASSWORD']

def auth_basic():
	return Response('No', 401, { 'WWW-Authenticate' : 'Basic realm="Login Required"' })

def req_auth_basic(f):
	@wraps(f)
	def fn(*args, **kwargs):
		auth = request.authorization
		if not auth or not check_auth_basic(auth.username, auth.password):
			return auth_basic()
		return f(*args, **kwargs)
	return fn

def generate_tshirt_names():
	out = []
	for tshirt in [ 'adult' ]:
		for size in [ 's', 'm', 'l', 'xl' ]:
			out.append("tshirt_{0}_{1}".format(tshirt, size))
	return out

# WTForms is a very nice form generation/validation tool in which one
# adds members to a Form class which provides oneliners for HTML generation
# and form validation
#
# we're totally mis-using it!
#
# we don't use the HTML generation, since our form is prettier & more
# dynamic than what it provides, and we split it up into two forms, one
# generic (TicketForm) for the always-visible form entries, one dynamically
# generated by make_form_individual_tickets() for the collapsible per-ticket
# parts (because we don't know the number of tickets beforehand)
# we use those for form validation, so once validated the rest of the code
# can assume content correctness
class TicketForm(Form):
	email = EmailField('email', validators=[
		validators.Email(message="Really an email?"),
		])

	ticket_normal = IntegerField('ticket_normal', validators=[
		validators.NumberRange(min=0, max=10),
		])
	ticket_billable = IntegerField('ticket_billable', validators=[
		validators.NumberRange(min=0, max=10),
		])

	token = IntegerField('token', validators=[
		validators.NumberRange(min=0),
		])

	for tshirt in generate_tshirt_names():
		vars()[tshirt] = IntegerField(tshirt, validators=[
			validators.NumberRange(min=0),
			])

	terms_payment = BooleanField('', default=False,
		validators=[
			validators.DataRequired(message="did not agree to terms")
		])
	terms_supervision = BooleanField('', default=False,
		validators=[
			validators.DataRequired(message="did not agree to terms")
		])

def make_form_individual_tickets(n_tickets_normal, n_tickets_billable):
	class IndividualTicketForm(Form):
		pass

	for i in range(n_tickets_normal):
		fmt = "ticket_normal_visitors_{0}".format(i)
		name = fmt + '_name'
		setattr(IndividualTicketForm, name, StringField(name, validators=[ validators.DataRequired() ]))

		for field in [ '_dob_year', '_dob_month', '_dob_day' ]:
			name = fmt + field
			setattr(IndividualTicketForm, name, IntegerField(name, validators=[ validators.NumberRange() ]))

		fmt += "_options"
		for field in [ '_premium_toggle', '_cleanup_toggle', '_veggy_toggle' ]:
			name = fmt + field
			setattr(IndividualTicketForm, name, BooleanField(name))

	for i in range(n_tickets_billable):
		fmt = "ticket_billable_visitors_{0}".format(i)
		name = fmt + '_name'
		setattr(IndividualTicketForm, name, StringField(name, validators=[ validators.DataRequired() ]))

		for field in [ '_dob_year', '_dob_month', '_dob_day' ]:
			name = fmt + field
			setattr(IndividualTicketForm, name, IntegerField(name, validators=[ validators.NumberRange() ]))

		fmt += "_options"
		for field in [ '_volunteering_toggle', '_cleanup_toggle', '_veggy_toggle' ]:
			name = fmt + field
			setattr(IndividualTicketForm, name, BooleanField(name))

	if (n_tickets_billable > 0):
		for e in [ 'name', 'address', 'vat' ]:
			name = 'ticket_billable_{0}'.format(e)
			setattr(IndividualTicketForm, name, StringField(name, validators=[ validators.DataRequired() ]))

	return IndividualTicketForm

def extract_billing_info(form_tickets):

	out = {}

	for e in [ 'name', 'address', 'vat' ]:
		field = getattr(form_tickets, 'ticket_billable_{0}'.format(e), None)
		out[e] = field.data if field else ''

	return out


def extract_products(cursor, form_general, form_tickets):

	p = map(dict, model.products_get(cursor))
	known_tickets = sorted([ t for t in p if 'ticket' in t['name'] ], key=lambda t: t['max_dob'], reverse=True)
	known_tshirts = [ t for t in p if 'tshirt' in t['name'] ]
	known_tokens = [ t for t in p if 'token' in t['name'] ]

	out = []

	n_tickets_normal = form_general.ticket_normal.data
	n_tickets_billable = form_general.ticket_billable.data

	D("n_tickets_normal/_billable={0}/{1}".format(n_tickets_normal, n_tickets_billable))

	def find_knowns(known, form):
		out = []
		for k_t in known_tshirts:
			n = getattr(form_general, k_t['name'], None)
			if not (n and n.data):
				continue
			D("found tshirt {0}: {1}".format(k_t['name'], n.data))
			out.append({
				'product_id' : k_t['id'],
				'n' : n.data,
				'person_name' : '',
				'person_dob' : '',
				'person_volunteers_during' : False,
				'person_volunteers_after' : False,
				'person_food_vegitarian' : False,
			})
		return out

	out.extend(find_knowns(known_tshirts, form_general))
	out.extend(find_knowns(known_tokens, form_general))

	D("scanning for normal tickets")
	for i in range(n_tickets_normal):
		fmt = 'ticket_normal_visitors_{0}'.format(i)
		dob = datetime.datetime(getattr(form_tickets, fmt + '_dob_year').data,
			getattr(form_tickets, fmt + '_dob_month').data,
			getattr(form_tickets, fmt + '_dob_day').data)
		relevant_ticket = None
		for t in [ t for t in known_tickets if t['billable'] ==  False ]:
			if dob >= t['max_dob']:
				relevant_ticket = t
				break
		D("adding ticket: name={0} id={1}".format(relevant_ticket['name'], relevant_ticket['id']))
		out.append({
			'product_id' : relevant_ticket['id'],
			'n' : 1,
			'person_dob' : dob,
			'person_name' : getattr(form_tickets, fmt + '_name').data,
			'person_volunteers_during' : not getattr(form_tickets, fmt + '_options_premium_toggle').data,
			'person_volunteers_after' : getattr(form_tickets, fmt + '_options_cleanup_toggle').data,
			'person_food_vegitarian' : getattr(form_tickets, fmt + '_options_veggy_toggle').data,
		})
	
	D("scanning for billable tickets")
	for i in range(n_tickets_billable):
		fmt = 'ticket_billable_visitors_{0}'.format(i)
		dob = datetime.datetime(getattr(form_tickets, fmt + '_dob_year').data,
			getattr(form_tickets, fmt + '_dob_month').data,
			getattr(form_tickets, fmt + '_dob_day').data)
		relevant_ticket = None
		for t in [ t for t in known_tickets if t['billable'] == True ]:
			if dob >= t['max_dob']:
				relevant_ticket = t
				break
		D("adding ticket: name={0} id={1}".format(relevant_ticket['name'], relevant_ticket['id']))
		out.append({
			'product_id' : relevant_ticket['id'],
			'n' : 1,
			'person_dob' : dob,
			'person_name' : getattr(form_tickets, fmt + '_name').data,
			'person_volunteers_during' : getattr(form_tickets, fmt + '_options_volunteering_toggle').data,
			'person_volunteers_after' : getattr(form_tickets, fmt + '_options_cleanup_toggle').data,
			'person_food_vegitarian' : getattr(form_tickets, fmt + '_options_veggy_toggle').data,
		})

	return out

def price_distribution_strategy(cursor, nonce):
	"""
	strategy to figure out where to apply any discounts
	"""
	price_total = model.get_purchase_total(g.db_cursor, nonce)
	price_billable = model.get_purchase_total(g.db_cursor, nonce)
	price_unbillable = price_total - price_billable
	price_discount = model.get_purchase_discount(g.db_cursor, nonce)

	if price_discount > price_total:
		# all expenses covered by discount
		return 0, 0

	if price_discount > price_unbillable:
		# total of unbillable covered by discount, leftover discount
		# applied to billable
		return 0, (price_billable - (price_discount - price_unbillable))

	# default, substract discount from unbillable
	return price_unbillable - price_discount, price_billable


@app.route('/tickets', methods=[ 'GET', 'POST' ])
@req_auth_basic
def tickets():
	form = TicketForm()
	tickets_available = app.config['TICKETS_MAX'] - model.get_total_tickets(g.db_cursor)

	if form.validate_on_submit():
		# the static part of the form is OK, we can check how large the dynamic part is
		# and build a validator accordingly
		n_tickets_normal = form.ticket_normal.data
		n_tickets_billable = form.ticket_billable.data
		n_tickets = n_tickets_normal + n_tickets_billable

		# check the reservation first
		reservation = model.reservation_find(g.db_cursor, form.email.data)
		if not reservation['available_from'] <= datetime.datetime.utcnow():
			# not so fast
			return redirect(url_for('retry', available_from=reservation['available_from']))

		individual_form = make_form_individual_tickets(n_tickets_normal, n_tickets_billable)()
		if individual_form.validate_on_submit():
			# the dynamic part of the form validated as well, get out all the data
			# and write to database
			products  = extract_products(g.db_cursor, form, individual_form)
			billing_info = extract_billing_info(individual_form)

			# create it all
			nonce = model.purchase_create(g.db_cursor, form.email.data, products, billing_info)

			# get the prices back (includes reservation discounts, volunteering discounts, ...)
			price_normal, price_billable = price_distribution_strategy(g.db_cursor, nonce)
			price_total = price_normal + price_billable

			mail_data = {
				'amount' : price_total,
				'days_max' : app.config['DAYS_MAX'],
				'email' : form.email.data
			}
			"""
			mail.send_mail(
				from_addr=app.config['MAIL_MY_ADDR'],
				to_addrs=[ form.email.data, app.config['MAIL_CC_ADDR'] ],
				subject=texts['MAIL_TICKETS_SUBJECT'],
				msg_html=texts['MAIL_TICKETS_HTML'].format(**mail_data),
				msg_text=texts['MAIL_TICKETS_TEXT'].format(**mail_data))
			"""
			g.db_commit = True
			return redirect(url_for('confirm', nonce=nonce))
		else:
			return redirect(url_for('retry'))
	else:
		return render_template('tickets.html', form=form, tickets_available=tickets_available)

@app.route('/retry/<reason>', methods=[ 'GET' ])
@req_auth_basic
def retry(reason=None):
	return render_template('retry.html', reason=reason)

@app.route('/confirm/<nonce>', methods=[ 'GET' ])
@req_auth_basic
def confirm(nonce=None):
	price_normal, price_billable = price_distribution_strategy(g.db_cursor, nonce)
	return render_template('confirm.html',
			price_total=price_normal + price_billable,
			price_billable=price_billable,
			days_max=app.config['DAYS_MAX'])

@app.route('/payments', methods=[ 'GET' ])
@req_auth_basic
def payments():
	now = datetime.datetime.utcnow()
	time_delta = datetime.timedelta(days=app.config['DAYS_MAX'])

	p = map(dict, model.get_purchases(g.db_cursor, strip_removed=False))
	for x in p:
		created_at = datetime.datetime.strptime(x['created_at'], '%Y-%m-%d %H:%M:%S.%f')
		if not x['paid'] and (created_at + time_delta) < now:
			x['overtime'] = True
		else:
			x['overtime'] = False

	return render_template('payments.html', purchases=p, page_opts={ 'internal' : True })

@app.route('/overview', methods=[ 'GET' ])
@req_auth_basic
def overview():
	overview_tickets = model.get_overview_tickets(g.db_cursor)
	overview_tshirts = model.get_overview_tshirts(g.db_cursor)
	return render_template('overview.html',
		overview_tickets=overview_tickets,
		overview_tshirts=overview_tshirts,
		page_opts={
			'charting' : True,
			'internal' : True})

@app.route('/api/purchase_mark_paid/<int:purchase_id>/<int:paid>', methods=[ 'GET' ])
@req_auth_basic
def api_purchase_mark_paid(purchase_id, paid):
	model.purchase_mark_paid(g.db_cursor, purchase_id)
	g.db_commit = True
	return "ok", 200

@app.route('/api/purchase_remove/<int:purchase_id>', methods=[ 'GET' ])
@req_auth_basic
def api_purchase_remove(purchase_id):
	model.purchase_remove(g.db_cursor, purchase_id)
	g.db_commit = True
	return "ok", 200

@app.route('/api/get_products', methods=[ 'GET' ])
@req_auth_basic
def api_get_products():
	products = map(dict, model.products_get(g.db_cursor))
	D(repr(products))
	for p in products:
		if p['max_dob']:
			p['max_dob'] = int(time.mktime(p['max_dob'].timetuple()))
	return json.dumps(products), 200

@app.route('/api/get_timeline_tickets')
@req_auth_basic
def api_get_timeline_tickets():
	timeline_tickets = map(dict, model.get_timeline_tickets(g.db_cursor))

	sum = 0
	for t in timeline_tickets:
		at = datetime.datetime.strptime(t['at'], '%Y-%m-%d %H:%M:%S.%f')
		epoch = datetime.datetime(1970, 1, 1)
		when = (at - epoch).total_seconds()
		t['at'] = int(when)

		sum += t['n']
		t['n'] = sum

	return json.dumps({
		'at' : [ t['at'] for t in timeline_tickets ],
		'n' : [ t['n'] for t in timeline_tickets ]})

@app.route("/api/get_reservation/<email>", methods=[ 'GET' ])
def api_get_reservation(email):
	r = model.reservation_find(g.db_cursor, email)
	# prune what we need
	return json.dumps({
			'discount' : r['discount'],
			'available_from' : int(time.mktime(r['available_from'].timetuple())),
		})
@app.route("/api/get_purchase_total/<nonce>", methods=[ 'GET' ])
def api_get_purchase_total(nonce):
	p = model.get_purchase_total(g.db_cursor, nonce)
	b = model.get_purchase_total(g.db_cursor, nonce, True)
	d = model.get_purchase_discount(g.db_cursor, nonce)
	D("d={0}".format(d))
	D("b={0}".format(b))
	# prune what we need
	return json.dumps({
			'price' : p-d,
		})

@app.route("/")
@req_auth_basic
def index():
	return render_template("index.html")
