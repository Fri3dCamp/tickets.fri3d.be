# -*- coding: utf-8 -*-
# vim: ts=4:sw=4:noexpandtab
from flask import request, jsonify, render_template, redirect, url_for, g, Response
from flask_wtf import Form
from wtforms import StringField, validators
from wtforms import BooleanField, IntegerField, TextAreaField
from wtforms.fields.html5 import EmailField, DateTimeField
from fr1ckets import app
from fr1ckets.texts import texts
from fr1ckets.model import model
from fr1ckets.mail import mail
from functools import wraps
import time
import json
import datetime

D = app.logger.debug

def check_auth_basic(u, p):
	return u == app.config['TEMP_SHIELDING_USERNAME'] and p == app.config['TEMP_SHIELDING_PASSWORD']

def auth_basic():
	return Response('No', 401, { 'WWW-Authenticate' : 'Basic realm="Login Required"' })

def req_auth_basic(f):
	@wraps(f)
	def fn(*args, **kwargs):
		auth = request.authorization
		if not auth or not check_auth_basic(auth.username, auth.password):
			return auth_basic()
		return f(*args, **kwargs)
	return fn

def generate_tshirt_names():
	out = []
	for tshirt in [ 'adult' ]:
		for size in [ 's', 'm', 'l', 'xl' ]:
			out.append("tshirt_{0}_{1}".format(tshirt, size))
	return out

# WTForms is a very nice form generation/validation tool in which one
# adds members to a Form class which provides oneliners for HTML generation
# and form validation
#
# we're totally mis-using it!
#
# we don't use the HTML generation, since our form is prettier & more
# dynamic than what it provides, and we split it up into two forms, one
# generic (TicketForm) for the always-visible form entries, one dynamically
# generated by make_form_individual_tickets() for the collapsible per-ticket
# parts (because we don't know the number of tickets beforehand)
# we use those for form validation, so once validated the rest of the code
# can assume content correctness
class TicketForm(Form):
	email = EmailField('email', validators=[
		validators.Email(message="Really an email?"),
		])

	n_tickets = IntegerField('n_tickets', validators=[
		validators.NumberRange(min=0, max=20),
		])

	token = IntegerField('token', validators=[
		validators.NumberRange(min=0, max=100),
		])

	for tshirt in generate_tshirt_names():
		vars()[tshirt] = IntegerField(tshirt, validators=[
			validators.NumberRange(min=0, max=10),
			])

	terms_payment = BooleanField('', default=False,
		validators=[
			validators.DataRequired(message="did not agree to terms")
		])
	terms_supervision = BooleanField('', default=False,
		validators=[
			validators.DataRequired(message="did not agree to terms")
		])
	terms_excellent = BooleanField('', default=False,
		validators=[
			validators.DataRequired(message="did not agree to terms")
		])

class BusinessForm(Form):
	business_name = StringField("business_name", validators=[ validators.DataRequired() ])
	business_address = StringField("business_address", validators=[ validators.DataRequired() ])
	business_vat = StringField("business_vat", validators=[ validators.DataRequired() ])

def make_form_individual_tickets(n_tickets):
	class IndividualTicketForm(Form):
		pass

	for i in range(n_tickets):
		fmt = "tickets_{0}".format(i)
		name = fmt + '_name'
		setattr(IndividualTicketForm, name, StringField(name, validators=[ validators.DataRequired() ]))

		name = fmt + '_billable'
		setattr(IndividualTicketForm, name, BooleanField(name))

		name = fmt + '_dob_year'
		setattr(IndividualTicketForm, name, IntegerField(name,
			validators=[
				validators.NumberRange(min=1900, max=datetime.date.fromtimestamp(time.time()).year)
				]))
		name = fmt + '_dob_month'
		setattr(IndividualTicketForm, name, IntegerField(name,
			validators=[
				validators.NumberRange(min=1, max=12)
				]))
		name = fmt + '_dob_day'
		setattr(IndividualTicketForm, name, IntegerField(name,
			validators=[
				validators.NumberRange(min=1, max=31)
				]))

		fmt += "_options"
		for field in [ '_volunteers_during', '_volunteers_after', '_vegitarian' ]:
			name = fmt + field
			setattr(IndividualTicketForm, name, BooleanField(name, default=False))
	D(IndividualTicketForm.__dict__)
	return IndividualTicketForm

def extract_billing_info(form_tickets):
	out = {}

	for e in [ 'name', 'address', 'vat' ]:
		field = getattr(form_tickets, 'business_{0}'.format(e), None)
		out[e] = field.data if field else ''

	return out

def extract_products(cursor, form_general, form_tickets):

	p = map(dict, model.products_get(cursor))
	known_tickets = sorted([ t for t in p if 'ticket' in t['name'] ], key=lambda t: t['max_dob'], reverse=True)
	known_tshirts = [ t for t in p if 'tshirt' in t['name'] ]
	known_tokens = [ t for t in p if 'token' in t['name'] ]
	seen_business_tickets = False
	out = []

	n_tickets = form_general.n_tickets.data

	def find_knowns(known, form):
		out = []
		D("finding knowns in {0}".format(known))
		for k_t in known:
			n = getattr(form, k_t['name'], None)
			if not (n and n.data):
				continue
			D("found {0}: {1}".format(k_t['name'], n.data))
			out.append({
				'product_id' : k_t['id'],
				'n' : n.data,
				'person_name' : '',
				'person_dob' : '',
				'person_volunteers_during' : False,
				'person_volunteers_after' : False,
				'person_food_vegitarian' : False,
			})
		return out

	out.extend(find_knowns(known_tshirts, form_general))
	out.extend(find_knowns(known_tokens, form_general))

	for i in range(n_tickets):
		fmt = 'tickets_{0}'.format(i)
		dob = datetime.datetime(getattr(form_tickets, fmt + '_dob_year').data,
			getattr(form_tickets, fmt + '_dob_month').data,
			getattr(form_tickets, fmt + '_dob_day').data)
		billable = getattr(form_tickets, fmt + '_billable').data
		relevant_ticket = None
		for t in [ t for t in known_tickets if t['billable'] == billable]:
			if dob >= t['max_dob']:
				relevant_ticket = t
				break
		if billable:
			seen_business_tickets = True
		D("adding ticket: name={0} id={1}".format(relevant_ticket['name'], relevant_ticket['id']))
		out.append({
			'product_id' : relevant_ticket['id'],
			'n' : 1,
			'person_dob' : dob,
			'person_name' : getattr(form_tickets, fmt + '_name').data,
			'person_volunteers_during' : getattr(form_tickets, fmt + '_options_volunteers_during').data,
			'person_volunteers_after' : getattr(form_tickets, fmt + '_options_volunteers_after').data,
			'person_food_vegitarian' : getattr(form_tickets, fmt + '_options_vegitarian').data,
		})
	
	return out, seen_business_tickets

def price_distribution_strategy(cursor, nonce):
	"""
	strategy to figure out where to apply any discounts
	"""
	price_total = model.get_purchase_total(g.db_cursor, nonce)
	price_billable = model.get_purchase_total(g.db_cursor, nonce, True)
	price_unbillable = price_total - price_billable
	price_discount = model.get_purchase_discount(g.db_cursor, nonce)

	if price_discount > price_total:
		# all expenses covered by discount
		return 0, 0

	if price_discount > price_unbillable:
		# total of unbillable covered by discount, leftover discount
		# applied to billable
		return 0, (price_billable - (price_discount - price_unbillable))

	# default, substract discount from unbillable
	return price_unbillable - price_discount, price_billable


@app.route('/tickets', methods=[ 'GET' ])
@req_auth_basic
def tickets():
	form = TicketForm()
	tickets_available = app.config['TICKETS_MAX'] - model.tickets_actual_total(g.db_cursor)
	return render_template('tickets.html', form=form, tickets_available=tickets_available)

@app.route('/api/tickets_register', methods=[ 'POST' ])
@req_auth_basic
def ticket_register():
	form = TicketForm()
	tickets_available = app.config['TICKETS_MAX'] - model.tickets_actual_total(g.db_cursor)

	if not form.validate_on_submit():
		return jsonify(
			status='FAIL',
			message=u"Het formulier is niet volledig! ({0})".format(", ".join(form.errors)))

	# the static part of the form is OK, we can check how large the dynamic part is
	# and build a validator accordingly
	n_tickets = form.n_tickets.data

	# check the reservation first
	reservation = model.reservation_find(g.db_cursor, form.email.data)
	if not reservation['available_from'] <= datetime.datetime.utcnow():
		# not so fast
		time_to_go = reservation['available_from'] - datetime.datetime.utcnow()
		return jsonify(
			status='FAIL',
			message=u"U kan slechts reserveren vanaf {0} UTC, probeer nogmaals over {1} seconden!".format(reservation['available_from'], int(time_to_go.total_seconds())))

	# validate the dynamic part
	individual_form = make_form_individual_tickets(n_tickets)()
	if not individual_form.validate_on_submit():
		# did not validate OK
		return jsonify(
			status='FAIL',
			message=u"Het formulier is niet volledig!")

	# the dynamic part of the form validated as well, get out all the data
	# and write to database
	products, contains_billables  = extract_products(g.db_cursor, form, individual_form)

	business_form = None
	if contains_billables:
		# one or more of the products are billable, validate business info
		business_form = BusinessForm()
		if not business_form.validate_on_submit():
			# business form parse failed
			return jsonify(
				status='FAIL',
				message=u"De zakelijke details zijn niet volledig!")

	billing_info = extract_billing_info(business_form)

	# create it all
	queued = True if tickets_available < n_tickets else False
	nonce = model.purchase_create(g.db_cursor, form.email.data, products, billing_info, queued)

	# get the prices back (includes reservation discounts, volunteering discounts, ...)
	price_normal, price_billable = price_distribution_strategy(g.db_cursor, nonce)
	price_total = price_normal + price_billable

	mail_data = {
		'amount' : price_total,
		'days_max' : app.config['DAYS_MAX'],
		'email' : form.email.data
	}

	if form.email.data[-len('.notreal'):] != '.notreal':
		if not queued:
			mail.send_mail(
				from_addr=app.config['MAIL_MY_ADDR'],
				to_addrs=[ form.email.data, app.config['MAIL_CC_ADDR'] ],
				subject=texts['MAIL_TICKETS_ORDERED_OK_SUBJECT'],
				msg_html=texts['MAIL_TICKETS_ORDERED_OK_HTML'].format(**mail_data),
				msg_text=texts['MAIL_TICKETS_ORDERED_OK_TEXT'].format(**mail_data))
		else:
			mail.send_mail(
				from_addr=app.config['MAIL_MY_ADDR'],
				to_addrs=[ form.email.data, app.config['MAIL_CC_ADDR'] ],
				subject=texts['MAIL_TICKETS_ORDERED_QUEUE_SUBJECT'],
				msg_html=texts['MAIL_TICKETS_ORDERED_QUEUE_HTML'].format(**mail_data),
				msg_text=texts['MAIL_TICKETS_ORDERED_QUEUE_TEXT'].format(**mail_data))


	g.db_commit = True

	# smashing!
	return jsonify(
		status='SUCCESS',
		redirect=url_for('confirm', nonce=nonce))

@app.route('/confirm/<nonce>', methods=[ 'GET' ])
@req_auth_basic
def confirm(nonce=None):
	price_normal, price_billable = price_distribution_strategy(g.db_cursor, nonce)
	purchase = model.purchase_get(g.db_cursor, nonce=nonce)
	return render_template('confirm.html',
			queued=purchase['queued'],
			price_total=price_normal + price_billable,
			price_billable=price_billable,
			days_max=app.config['DAYS_MAX'])

@app.route('/admin/payments', methods=[ 'GET' ])
@req_auth_basic
def payments():
	now = datetime.datetime.utcnow()
	time_delta = datetime.timedelta(days=app.config['DAYS_MAX'])

	p = map(dict, model.get_purchases(g.db_cursor, strip_removed=False))
	tickets_total = model.tickets_actual_total(g.db_cursor)
	tickets_available = app.config['TICKETS_MAX'] - tickets_total
	tickets_available_dequeueing = tickets_available
	purchases_dequeueable = 0

	considering_dequeue = True
	tickets_queued = 0
	for x in p:
		if not x['paid'] and (x['created_at'] + time_delta) < now:
			x['overtime'] = True
		else:
			x['overtime'] = False

		x['can_dequeue'] = False
		if considering_dequeue and x['queued'] and not x['removed']:
			# encountered a queued one, can we show it as dequeue-able?
			if x['n_tickets'] <= tickets_available_dequeueing:
				x['can_dequeue'] = True
				tickets_available_dequeueing -= x['n_tickets']
				purchases_dequeueable += 1
			else:
				considering_dequeue = False
		if x['queued']:
			tickets_queued += x['n_tickets']

	return render_template('payments.html',
			tickets_total=tickets_total, tickets_available=tickets_available,
			purchases_dequeueable=purchases_dequeueable, tickets_queued=tickets_queued,
			purchases=p, page_opts={ 'internal' : True })

@app.route('/admin/reservations')
@req_auth_basic
def reservations():
	"""
	build a list of reservations, return
	"""
	r = model.reservation_get(g.db_cursor)
	return render_template('reservations.html', reservations=r,
			page_opts={
				'internal' : True
			})

@app.route('/admin/reservation_delete/<int:id>')
@req_auth_basic
def reservation_delete(id):
	"""
	delete a reservation based on id
	"""
	model.reservation_delete(g.db_cursor, id=id)
	g.db_commit = True
	return redirect(url_for('reservations'))

class ReservationForm(Form):
	"""
	reservation manipulation form
	"""
	email = EmailField('Email address', validators=[
		validators.Email(message="Really an email?"),
		])
	discount = IntegerField(u'Discount on order in €', validators=[
		validators.NumberRange(message='Not a number!', min=0),
		])
	available_from = DateTimeField('Can be used from (UTC)', format='%Y-%m-%d %H:%M:%S', validators=[
		validators.Required('Needed field.'),
		])
	claimed = BooleanField('Has been claimed')
	claimed_at = DateTimeField('Was claimed at (UTC)', format='%Y-%m-%d %H:%M:%S', validators=[
		validators.Optional(),
		])
	comments = TextAreaField('Internal comments', validators=[
		validators.Optional(),
		])

@app.route('/admin/reservation_edit/<int:id>', methods=[ 'GET', 'POST'])
@req_auth_basic
def reservation_edit(id):
	"""
	overwrite reservation by id
	"""
	form = ReservationForm()
	if form.validate_on_submit():
		# form validated, pack and save
		changeset = {
			'email' : form.email.data,
			'discount' : form.discount.data,
			'available_from' : form.available_from.data,
			'claimed' : bool(form.claimed.data),
			'claimed_at' : form.claimed_at.data or '',
			'comments' : form.comments.data,
		}
		model.reservation_update(g.db_cursor, id, changeset)
		g.db_commit = True
		# back to list
		return redirect(url_for('reservations'))
	# no form entry or bad validation, show form
	res = map(dict, model.reservation_get(g.db_cursor, id))
	for r in res:
		r['claimed'] = bool(r['claimed'])
	return render_template('reservation_edit.html', reservation=res[0],
			form=form,
			page_opts={
				'internal' : True
			},
			form_dest=url_for('reservation_edit', id=id))

@app.route('/admin/reservation_add', methods=[ 'GET', 'POST'])
@req_auth_basic
def reservation_add():
	"""
	add a reservation
	"""
	form = ReservationForm()
	if form.validate_on_submit():
		# form validated, pack and save
		changeset = {
			'email' : form.email.data,
			'discount' : form.discount.data,
			'available_from' : form.available_from.data,
			'claimed' : bool(form.claimed.data),
			'claimed_at' : form.claimed_at.data or '',
			'comments' : form.comments.data,
		}
		model.reservation_create(g.db_cursor, changeset)
		g.db_commit = True
		# back to list
		return redirect(url_for('reservations'))
	# no form entry or bad validation, show the form, we use the
	# always-existing "default" reservation (used when no specific hit
	# was found) as a template, and substract a week since the caller
	# will likely want to make a prereservation
	default_id = model.reservation_find(g.db_cursor, 'default')['id']
	default_r = dict(model.reservation_get(g.db_cursor, default_id)[0])
	default_r['email'] = u''
	default_r['discount'] = 0
	default_r['available_from'] -= datetime.timedelta(weeks=1)
	default_r['claimed'] = bool(default_r['claimed'])
	return render_template('reservation_edit.html', reservation=default_r,
			form=form,
			page_opts={
				'internal' : True
			},
			form_dest=url_for('reservation_add', id=id))

@app.route('/admin/overview', methods=[ 'GET' ])
@req_auth_basic
def overview():
	overview_tickets = model.get_overview_tickets(g.db_cursor)
	overview_tshirts = model.get_overview_tshirts(g.db_cursor)
	overview_tokens = model.get_overview_tokens(g.db_cursor)
	return render_template('overview.html',
		overview_tickets=overview_tickets,
		overview_tshirts=overview_tshirts,
		overview_tokens=overview_tokens,
		page_opts={
			'charting' : True,
			'internal' : True})

@app.route('/admin/api/purchase_mark_paid/<int:purchase_id>/<int:paid>', methods=[ 'GET' ])
@req_auth_basic
def api_purchase_mark_paid(purchase_id, paid):
	model.purchase_mark_paid(g.db_cursor, purchase_id, paid)

	if paid:
		purchase = model.purchase_get(g.db_cursor, id=purchase_id)
		email = purchase['email']

		if email[-len('.notreal'):] != '.notreal':
			mail.send_mail(
				from_addr=app.config['MAIL_MY_ADDR'],
				to_addrs=[ email, app.config['MAIL_CC_ADDR'] ],
				subject=texts['MAIL_PAYMENT_RECEIVED_SUBJECT'],
				msg_html=texts['MAIL_PAYMENT_RECEIVED_HTML'],
				msg_text=texts['MAIL_PAYMENT_RECEIVED_TEXT'])

	g.db_commit = True
	return "ok", 200

@app.route('/admin/api/purchase_mark_removed/<int:purchase_id>/<int:removed>', methods=[ 'GET' ])
@req_auth_basic
def api_purchase_mark_removed(purchase_id, removed):
	model.purchase_mark_removed(g.db_cursor, purchase_id, removed)
	g.db_commit = True
	return "ok", 200

@app.route('/admin/api/purchase_mark_dequeued/<int:purchase_id>', methods=[ 'GET' ])
@req_auth_basic
def api_purchase_mark_dequeued(purchase_id):
	model.purchase_mark_dequeued(g.db_cursor, purchase_id)
	purchase = model.purchase_get(g.db_cursor, id=purchase_id)
	email = purchase['email']

	price_normal, price_billable = price_distribution_strategy(g.db_cursor, purchase['nonce'])
	price_total = price_normal + price_billable

	mail_data = {
		'amount' : price_total,
		'days_max' : app.config['DAYS_MAX'],
		'email' : email,
	}

	if email[-len('.notreal'):] != '.notreal':
		mail.send_mail(
			from_addr=app.config['MAIL_MY_ADDR'],
			to_addrs=[ email, app.config['MAIL_CC_ADDR'] ],
			subject=texts['MAIL_UNQUEUED_SUBJECT'],
			msg_html=texts['MAIL_UNQUEUED_HTML'].format(**mail_data),
			msg_text=texts['MAIL_UNQUEUED_TEXT'].format(**mail_data))

	g.db_commit = True
	return "ok", 200


@app.route('/api/get_products', methods=[ 'GET' ])
@req_auth_basic
def api_get_products():
	products = map(dict, model.products_get(g.db_cursor))
	for p in products:
		if p['max_dob']:
			p['max_dob'] = int(time.mktime(p['max_dob'].timetuple()))
	return json.dumps(products), 200

@app.route('/admin/api/get_timeline_tickets')
@req_auth_basic
def api_get_timeline_tickets():
	timeline_tickets = map(dict, model.get_timeline_tickets(g.db_cursor))

	sum = 0
	for t in timeline_tickets:
		epoch = datetime.datetime(1970, 1, 1)
		when = (t['at'] - epoch).total_seconds()
		t['at'] = int(when)
		sum += int(t['n'])
		t['n'] = sum

	return json.dumps({
		'at' : [ t['at'] for t in timeline_tickets ],
		'n' : [ t['n'] for t in timeline_tickets ]})

@app.route("/api/get_reservation/<email>", methods=[ 'GET' ])
def api_get_reservation(email):
	r = model.reservation_find(g.db_cursor, email)
	# prune what we need
	return json.dumps({
			'discount' : r['discount'],
			'available_from' : int(time.mktime(r['available_from'].timetuple())),
		})

@app.route("/")
@req_auth_basic
def index():
	return render_template("index.html")
